---
layout: post
title: SpringBoot - 集成Quartz以实现定时任务（内存篇）
tags:
- Java 
- SpringBoot 
- Tips
categories: Java
description: 使用RestTemplate发送Http请求
---  
**SpringBoot定时任务 — Quartz最快速的集成及使用（定时任务未持久化）**

<!-- more -->
## 一、最前面
**1.定时任务框架选型**  
1）简单的有Java自带的[Timer](https://docs.oracle.com/javase/7/docs/api/java/util/Timer.html)、
[ScheduledExecutorService](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html)，
Spring自带的[Task](https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/scheduling.html)。  
2）相较复杂的分布式定时任务中间件有[XXL-JOB](https://www.xuxueli.com/xxl-job/#/)、[ElasticJob](https://github.com/apache/shardingsphere-elasticjob)等。  
**2.为什么是Quartz**  
简单的适用场景过于单一无法处理复杂的业务，而复杂的相较Quartz过于复杂且学习成本较高，仅用于新手学习而言Quartz较为合适。  
## 二、引入
SpringBoot从2.0起整合了Quartz，因此只需要引入一个starter即可食用。  
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-quartz</artifactId>
    <version>2.0.3.RELEASE</version>      <!-- 当前发布的最新版本 -->
</dependency>
```
## 三、配置
在application.yml中做如下配置即可。  
```yaml
spring:
  quartz:
    job-store-type: memory                             #所有任务相关内容存储在内存中
    scheduler-name: AnchorScheduler
    properties:
      org.quartz.scheduler.instanceId: 1122334         #集群中会用到，单节点无用，不填、填AUTO都可以
      org.quartz.scheduler.rmi.export: false
      org.quartz.scheduler.rmi.proxy: false
      org.quartz.scheduler.wrapJobExecutionInUserTransaction: false
      org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool
      org.quartz.threadPool.threadCount: 9             #线程数
      org.quartz.threadPool.threadPriority: 5          #线程优先级
      org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true
      org.quartz.jobStore.misfireThreshold: 60000      #作业最大延迟时间，毫秒
      org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore    #内存作业时负责跟踪调度所有工作数据
```
## 四、基本三元素
　— **JobDetail**，定时任务中的**“任务”**  
　— **Trigger**，定时任务中的**“定时”**  
　— **Scheduler**，定时任务的**调度器**  
## 五、增删查改