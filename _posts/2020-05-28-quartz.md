---
layout: post
title: SpringBoot - 集成Quartz实现定时任务（内存篇）
tags:
- Java 
- SpringBoot 
- Tips
categories: Java
description: 使用RestTemplate发送Http请求
---  
**SpringBoot定时任务 — Quartz最快速的集成及使用（定时任务未持久化）**

<!-- more -->
## 一、前言
**1.定时任务框架选型**  
1）简单的有Java自带的[Timer](https://docs.oracle.com/javase/7/docs/api/java/util/Timer.html)、
[ScheduledExecutorService](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html)，
Spring自带的[Task](https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/scheduling.html)。  
2）相较复杂的分布式定时任务中间件有[XXL-JOB](https://www.xuxueli.com/xxl-job/#/)、[ElasticJob](https://github.com/apache/shardingsphere-elasticjob)等。  
**2.为什么是Quartz**  
简单的适用场景过于单一无法处理复杂的业务，而复杂的相较Quartz过于复杂且学习成本较高，仅用于新手学习而言Quartz较为合适。  
## 二、引入
SpringBoot从2.0起整合了Quartz，因此只需要引入一个starter即可食用。  
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-quartz</artifactId>
    <version>2.0.3.RELEASE</version>      <!-- 当前发布的最新版本 -->
</dependency>
```
## 三、配置
在application.yml中做如下配置即可。  
```yaml
spring:
  quartz:
    job-store-type: memory                             #所有任务相关内容存储在内存中
    scheduler-name: AnchorScheduler
    properties:
      org.quartz.scheduler.instanceId: 1122334         #集群中会用到，单节点无用，不填、填AUTO都可以
      org.quartz.scheduler.rmi.export: false
      org.quartz.scheduler.rmi.proxy: false
      org.quartz.scheduler.wrapJobExecutionInUserTransaction: false
      org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool
      org.quartz.threadPool.threadCount: 9             #线程数
      org.quartz.threadPool.threadPriority: 5          #线程优先级
      org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true
      org.quartz.jobStore.misfireThreshold: 60000      #作业最大延迟时间，毫秒
      org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore    #内存作业时负责跟踪调度所有工作数据
```
`注：`SpringBoot会根据yml中spring.quartz下的内容自动注入相关的Bean，具体实现代码在**QuartzAutoConfiguration.class**中。
## 四、基本
Quartz中有三个基本"组件"，由它们共同来定义、运行一个定时任务：  
　— **JobDetail**，定时任务中的**“任务”**；  
　— **Trigger**，定时任务中的**“定时”**；  
　— **Scheduler**，定时任务的**调度器**；  
## 五、使用
#### 1.创建任务
**1）**在Quartz中创建的所有任务都要实现**Job**接口，但是在SpringBoot中所有的任务只要继承**QuartzJobBean**类即可。  
**2）**QuartzJobBean是一个抽象类，实现了Quartz的Job接口，实际上它是将Job中的execute()方法包装成了executeInternal()。  
**2）**与Thread的run()方法类似，定时任务的具体实现写在**executeInternal()**方法中。  
**3）**每创建一个新的定时任务，都需要新建一个Java类并继承QuartzJobBean、实现executeInternal()。  
```java
//SimpleJob是一个简单定时任务体，用于打印出当前线程名、当前时间及当前调用次数
public class SimpleJob extends QuartzJobBean {

    private final static AtomicInteger counter = new AtomicInteger(1);

    @Override
    protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        LocalDateTime now = LocalDateTime.now();
        String name = Thread.currentThread().getName();
        System.out.println("Execute quartz \"SimpleJob\", threadName = \"" + name +
                "\", the " + counter.getAndIncrement() + "th execution, time = \"" +
                now.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")) + "\"");
    }
}
```
#### 2.创建JobDetail
使用建造者模式的**JobBuilder**来创建一个JobDetail对象。  
```java
JobDetail simpleJob = JobBuilder.newJob(SimpleJob.class)        //传入一个Job类
                                .withIdentity("SimpleJob", "AnchorJobs")    //(name, group)标识唯一一个JobDetail
                                .storeDurably()        //在没有Trigger关联的情况下保存该任务到调度器
                                .build();
```
`注：`  
**1）**newJob()中传入的Job类必须是继承了QuartzJobBean的类。  
**2）**withIdentity()中group可不传，不传时默认设为"DEFAULT"。  
**3）**storeDurably()使JobDetail可在没有关联Trigger的情况下添加到调度器中，否则会抛异常。建议调用此方法。
#### 3.创建Trigger
常用Trigger有两种：**SimpleTrigger**和**CronTrigger**。二者最大的区别是CronTrigger支持Cron表达式，更灵活，因此使用CronTrigger居多。  
**1）创建SimpleTrigger**
```java
SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder
                                        .simpleSchedule()
                                        .withIntervalInSeconds(5)      //每5秒执行一次
                                        .repeatForever();              //无限循环执行
SimpleTrigger simpleTrigger = TriggerBuilder.newTrigger()
                                      .withIdentity("SimpleTrigger", "AnchorTriggers")    //(name, group)唯一标识一个Trigger
                                      .startNow()
                                      .withSchedule(scheduleBuilder)
                                      .build();
```
**2）创建CronTrigger**
```java
CronScheduleBuilder scheduleBuilder = CronScheduleBuilder.cronSchedule("0/5 * * * * ?");    //Cron表达式，每5秒执行一次
CronTrigger cronTrigger = TriggerBuilder.newTrigger()
                                    .withIdentity("CronJob", "AnchorTriggers")    //(name, group)唯一标识一个Trigger
                                    .startNow()
                                    .withSchedule(scheduleBuilder)      //不同的scheduleBuilder
                                    .build();
```
#### 4.启动任务
```java
@Resource
private Scheduler scheduler;          //SpringBoot会根据我们上文的配置自动注入Scheduler

scheduler.scheduleJob(simpleJob, simpleTrigger);
//或scheduler.scheduleJob(simpleJob, cronTrigger);
```
`注：`一个Job只能绑定一个Trigger。同一个Job不能用两个Trigger去触发，同一个Trigger也不能去触发两个Job。
## 六、增删查改